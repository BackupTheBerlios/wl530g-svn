diff -bBurN linux-2.4.32-uc0-wl530g/net/core/dev.c linux-2.4.32-uc0-wl530g.fastrt/net/core/dev.c
--- linux-2.4.32-uc0-wl530g/net/core/dev.c	2005-07-20 04:43:46.000000000 +0300
+++ linux-2.4.32-uc0-wl530g.fastrt/net/core/dev.c	2006-09-10 16:33:31.000000000 +0300
@@ -110,6 +110,55 @@
 extern int plip_init(void);
 #endif
 
+/* for fast route, ugly, but save time
+ */
+#include <net/protocol.h>
+#include <net/ip.h>
+#include <net/route.h>
+#include <net/ip_fib.h>
+#include <net/arp.h>
+#include <net/tcp.h>
+#include <net/icmp.h>
+
+#include <linux/netfilter_bridge.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ip_conntrack_core.h>
+
+#include "../net/bridge/br_private.h"
+
+extern struct neigh_table arp_tbl; 
+
+extern unsigned int
+ip_nat_fn(unsigned int hooknum,
+	  struct sk_buff **pskb,
+	  const struct net_device *in,
+	  const struct net_device *out,
+	  int (*okfn)(struct sk_buff *));
+	  
+extern inline int
+ip_rcv_finish(struct sk_buff *skb);
+
+extern unsigned int
+ipt_hook(unsigned int hook,
+	 struct sk_buff **pskb,
+	 const struct net_device *in,
+	 const struct net_device *out,
+	 int (*okfn)(struct sk_buff *));
+	 
+extern unsigned int
+ip_nat_out(unsigned int hooknum,
+	   struct sk_buff **pskb,
+	   const struct net_device *in,
+	   const struct net_device *out,
+	   int (*okfn)(struct sk_buff *));
+	   
+extern unsigned int
+ip_refrag(unsigned int hooknum,
+	struct sk_buff **pskb,
+	const struct net_device *in,
+	const struct net_device *out,
+	int (*okfn)(struct sk_buff *));
+
 
 /* This define, if set, will randomly drop a packet when congestion
  * is more than moderate.  It helps fairness in the multi-interface
@@ -1546,6 +1595,465 @@
 	return ret;
 }
 
+
+static int process_br_learning(struct sk_buff *skb)
+{
+	struct net_bridge *br;
+	struct net_bridge_port *p;
+	
+	
+	p = skb->dev->br_port;
+	if (p == NULL)
+		return 0;
+	br = p->br;
+
+	if (!(br->dev.flags & IFF_UP))
+		return 0;
+
+	if (skb->mac.ethernet->h_source[0] & 1)
+		return 0;
+		
+	br_fdb_insert(br, p, skb->mac.ethernet->h_source, 0);
+	
+	return 1;
+}
+
+#define NF_HOOK_DIRECT_CALL(fun, hook, skb, indev, outdev, okfn) \
+do \
+{ \
+	switch (fun(hook, &skb, (const struct net_device *) indev, \
+		(const struct net_device *) outdev, okfn)) \
+	{ \
+	case NF_ACCEPT: \
+		break; \
+	case NF_STOLEN: \
+		return 1; \
+	case NF_QUEUE:  /* if you want to support this, modify code */ \
+	case NF_REPEAT: /* if you want to support this, modify code */ \
+	case NF_DROP: \
+	default: \
+		kfree_skb(skb); \
+		return 1; \
+	} \
+} while (0)
+
+unsigned int bypass_fast_rt=0;
+
+void set_bypass_fast_rt(void)
+{
+	bypass_fast_rt=1;
+}
+
+static int process_lan_to_wan(struct sk_buff *skb)
+{
+	struct net_bridge *br;
+	struct net_bridge_port *port;
+	struct iphdr *iph;
+	struct in_device *in_dev;
+	struct rt_key key;
+	struct fib_result res;
+	struct neighbour *n;
+	u32    next_hop;
+	
+	port = skb->dev->br_port;
+	if (port == NULL)
+		return 0;
+	br = port->br;
+	
+	if (!(br->dev.flags & IFF_UP))
+		return 0;
+
+	if (skb->mac.ethernet->h_source[0] & 1)
+		return 0;
+	
+	iph = (struct iphdr *) skb->data;
+			
+	if (memcmp(skb->mac.ethernet->h_dest, 
+		br->dev.dev_addr, ETH_ALEN) == 0) {
+					
+		if (skb->protocol != htons(ETH_P_IP))
+			return 0;
+			
+		/* do not speed up fragmented packets
+		 */
+		if (iph->frag_off & htons(IP_MF|IP_OFFSET))
+			return 0;
+		
+		/* error check and do not speed up packet
+		 * with IP options
+		 */
+		if (iph->ihl != 5 || iph->version != 4)
+			return 0;
+			
+		if ((in_dev = __in_dev_get(&br->dev)) == NULL)
+			return 0;
+			
+		/* check if this packet is for us, we only check first address
+		 * if you want to support secondary address, you need to modify 
+		 * code to do that
+		 */ 
+		if (iph->daddr == in_dev->ifa_list->ifa_address)
+			return 0;
+			
+		if (MULTICAST(iph->daddr) || BADCLASS(iph->daddr) ||
+			ZERONET(iph->daddr))
+			return 0;
+			
+		if (iph->daddr == 0xFFFFFFFF || (iph->saddr == 0 && iph->daddr == 0))
+			return 0;
+			
+		/* check if this packet should be routed to WAN
+		 */
+		key.dst		= iph->daddr;
+		key.src		= iph->saddr;
+		key.tos		= iph->tos;
+#ifdef CONFIG_IP_ROUTE_FWMARK
+		key.fwmark	= skb->nfmark;
+#endif
+		key.iif		= br->dev.ifindex;
+		key.oif		= 0;
+		key.scope	= RT_SCOPE_UNIVERSE;
+		
+		if (main_table->tb_lookup(main_table, &key, &res) != 0)
+			return 0;
+			
+		if (strcmp(res.fi->fib_dev->name, "WAN") != 0)
+			return 0;
+		
+		/* get next hop for this packet
+		 */
+		next_hop = res.fi->fib_nh[0].nh_gw;
+		if (next_hop == 0)
+			next_hop = iph->daddr;
+		
+		/* look up H/W address for destination IP
+		 */	
+		n = __neigh_lookup(&arp_tbl, &next_hop, res.fi->fib_dev, 0);
+		
+		if (!n)
+			return 0;
+		
+	} else
+		return 0;
+			
+	br->statistics.rx_packets++;
+	br->statistics.rx_bytes += skb->len;
+
+	if (nf_bridge_alloc(skb) == NULL)
+		return 0;
+		
+	br_fdb_insert(br, port, skb->mac.ethernet->h_source, 0);
+
+	skb->nf_bridge->physindev = skb->dev;
+	skb->dev = &br->dev;
+	
+	if (skb->stamp.tv_sec == 0)
+		do_gettimeofday(&skb->stamp);
+
+	netdev_rx_stat[smp_processor_id()].total++;
+
+	skb->h.raw = skb->nh.raw = skb->data;
+	
+	/* here, we only take care of nat and filter tables
+	 * if you want to support mangle table, you need to modify
+	 * code to do that.
+	 */
+	
+	/* NF_IP_PRE_ROUTING
+	 */
+	NF_HOOK_DIRECT_CALL(ip_conntrack_in, NF_IP_PRE_ROUTING, 
+		skb, skb->dev, NULL, NULL); 
+		
+	NF_HOOK_DIRECT_CALL(ip_nat_fn, NF_IP_PRE_ROUTING, 
+		skb, skb->dev, NULL, NULL);
+	 
+	/* NF_IP_FORWARD
+	 */
+	NF_HOOK_DIRECT_CALL(ipt_hook, NF_IP_FORWARD, 
+		skb, skb->dev, res.fi->fib_dev, NULL);
+		
+	ip_decrease_ttl(iph);
+	 
+	/* NF_IP_POST_ROUTING
+	 */
+	NF_HOOK_DIRECT_CALL(ip_nat_out, NF_IP_POST_ROUTING, 
+		skb, NULL, res.fi->fib_dev, NULL);
+	NF_HOOK_DIRECT_CALL(ip_refrag, NF_IP_POST_ROUTING, 
+		skb, NULL, res.fi->fib_dev, NULL);	
+		
+	skb->dev = res.fi->fib_dev;
+	memcpy(skb->mac.ethernet->h_dest, n->ha, ETH_ALEN);
+	memcpy(skb->mac.ethernet->h_source, skb->dev->dev_addr, ETH_ALEN);
+	neigh_release(n);
+	skb_push(skb, ETH_HLEN);
+	dev_queue_xmit(skb);
+	
+	return 1;
+}
+
+
+static int process_wan_to_lan(struct sk_buff *skb)
+{
+	struct iphdr *iph;
+	struct in_device *in_dev;
+	struct net_device *out_net_dev;
+	struct neighbour *n;
+	struct net_bridge *br;
+	struct net_bridge_fdb_entry *dst;
+	
+	iph = (struct iphdr *) skb->data;
+	
+	if (memcmp(skb->mac.ethernet->h_dest, 
+		skb->dev->dev_addr, ETH_ALEN) == 0) {
+					
+		if (skb->protocol != htons(ETH_P_IP))
+			return 0;
+			
+		/* do not speed up fragmented packets
+		 */
+		if (iph->frag_off & htons(IP_MF|IP_OFFSET))
+			return 0;
+		
+		/* error check and do not speed up packet
+		 * with IP options
+		 */
+		if (iph->ihl != 5 || iph->version != 4)
+			return 0;
+			
+		if ((in_dev = __in_dev_get(skb->dev)) == NULL)
+			return 0;
+			
+		/* check if this packet is for us, we only check first address
+		 * if you want to support secondary address, you need to modify 
+		 * code to do that
+		 */ 
+		if (iph->daddr != in_dev->ifa_list->ifa_address)
+			return 0;
+	
+#if 0           
+		/* for performance, we assume the packet is all right
+      		 */
+		if (ip_fast_csum((u8 *)iph, iph->ihl) != 0)
+			return 0;
+#endif
+			
+		{
+		__u32 len = ntohs(iph->tot_len); 
+		if (skb->len < len || len < (iph->ihl<<2))
+			return 0;
+
+		/* Our transport medium may have padded the buffer out. Now we know it
+		 * is IP we can trim to the true length of the frame.
+		 * Note this now means skb->len holds ntohs(iph->tot_len).
+		 */
+		if (skb->len > len)
+			__pskb_trim(skb, len);
+		}
+			
+	} else
+		return 0;
+		
+	if (skb->stamp.tv_sec == 0)
+		do_gettimeofday(&skb->stamp);
+
+	netdev_rx_stat[smp_processor_id()].total++;
+
+	skb->h.raw = skb->nh.raw = skb->data;
+	
+	/* here, we only take care of nat and filter tables
+	 * if you want to support mangle table, you need to modify
+	 * code to do that.
+	 */
+	
+	/* NF_IP_PRE_ROUTING
+	 */
+	NF_HOOK_DIRECT_CALL(ip_conntrack_in, NF_IP_PRE_ROUTING, 
+		skb, skb->dev, NULL, NULL); 
+		
+	NF_HOOK_DIRECT_CALL(ip_nat_fn, NF_IP_PRE_ROUTING, 
+		skb, skb->dev, NULL, NULL);
+	
+	/* if destination is for us (WAN), send this packet to protocol stack
+	 */	
+	if (skb->nh.iph->daddr == in_dev->ifa_list->ifa_address) {
+		
+		ip_rcv_finish(skb);
+		goto done;
+	}
+		
+	/* under NAT, the output device must be bridge of LAN
+	 */
+	out_net_dev = dev_get_by_name("br0");
+	
+	if (out_net_dev == NULL) {
+		
+		ip_rcv_finish(skb);  /* should not happen */
+		goto done;
+	}
+	
+	if ((in_dev = __in_dev_get(out_net_dev)) == NULL) {
+		
+		ip_rcv_finish(skb);  /* should not happen */
+		goto done;
+	}
+	
+	/* if destination is for us (bridged LAN), send this packet to protocol stack
+	 */
+	if (skb->nh.iph->daddr == in_dev->ifa_list->ifa_address) {
+		
+		ip_rcv_finish(skb);
+		goto done;
+	}	
+		
+	/* look up H/W address for destination IP
+	 */	
+	n = __neigh_lookup(&arp_tbl, &skb->nh.iph->daddr, out_net_dev, 0);
+		
+	if (!n) {
+		
+		ip_rcv_finish(skb);  /* ARP not created, go normal path */
+		goto done;
+	}
+	
+	/* if you want to support MAC filter, you need to modify code
+	 * to support it.
+	 */
+		
+	br = (struct net_bridge *) out_net_dev->priv;
+	
+	if ((dst = br_fdb_get(br, n->ha)) == NULL) {
+		
+		ip_rcv_finish(skb);  /* not learned, go normal path */ 
+		goto done;
+	}
+
+	/* NF_IP_FORWARD
+	 */
+	NF_HOOK_DIRECT_CALL(ipt_hook, NF_IP_FORWARD, 
+		skb, skb->dev, out_net_dev, NULL);
+		
+	ip_decrease_ttl(iph);
+	 
+	/* NF_IP_POST_ROUTING
+	 */
+	NF_HOOK_DIRECT_CALL(ip_nat_out, NF_IP_POST_ROUTING, 
+		skb, NULL, out_net_dev, NULL);
+	NF_HOOK_DIRECT_CALL(ip_refrag, NF_IP_POST_ROUTING, 
+		skb, NULL, out_net_dev, NULL);
+		
+	skb->dev = dst->dst->dev;
+	memcpy(skb->mac.ethernet->h_dest, n->ha, ETH_ALEN);
+	memcpy(skb->mac.ethernet->h_source, skb->dev->dev_addr, ETH_ALEN);
+	neigh_release(n);
+	skb_push(skb, ETH_HLEN);
+	dev_queue_xmit(skb);
+	br_fdb_put(dst);
+		
+done:
+	return 1;
+}
+
+
+static int process_fast_rt(struct sk_buff *skb)
+{
+	/* if you want to support MAC filer, you should take care of it by yourself
+	 * that is, you should modify related code by yourself
+	 */
+	if (bypass_fast_rt) return 0;
+
+	if (strcmp(skb->dev->name, "WAN") == 0) {			
+		return (process_wan_to_lan(skb));	
+			
+	} else if ((strcmp(skb->dev->name, "LAN") == 0) || 
+		(strcmp(skb->dev->name, "wlan0") == 0)) {
+
+		return (process_lan_to_wan(skb));
+
+	}
+		
+	return 0;
+}
+
+typedef int (*FUN_CALL_T)(struct net_device *dev, u8 *sta_addr, u8 delSta);
+static struct net_device *lan_dev = NULL;
+static struct net_device *wlan0_dev = NULL;
+static u8 lan_cached_MAC[ETH_ALEN];
+
+static int process_fast_br(struct sk_buff *skb)
+{
+	FUN_CALL_T sta_existed;
+	struct net_device *dev;
+	
+	
+	/* 1. if you want to support MAC filer, you should take care of it by yourself
+	 *    that is, you should modify related code by yourself
+	 * 2. if you want to support spanning tree, you should take care of it by yourself
+	 *    taht is, you should modify related code by yourself
+	 */
+	
+	dev = skb->dev;
+
+	if (strcmp(dev->name, "wlan0") == 0) {
+
+		if (wlan0_dev == NULL)
+			wlan0_dev = dev;
+
+		if (lan_dev != NULL) {
+
+			if (memcmp(lan_cached_MAC, skb->mac.ethernet->h_dest, ETH_ALEN) == 0) {
+				if (!process_br_learning(skb))
+					goto err;
+				skb->dev = lan_dev;
+				skb_push(skb, ETH_HLEN);
+				dev_queue_xmit(skb);
+				return 1;
+			}
+		}
+
+	} else if (strcmp(dev->name, "LAN") == 0) {
+
+		if (lan_dev == NULL)
+			lan_dev = dev;
+
+		if (wlan0_dev != NULL) {
+
+			sta_existed = (FUN_CALL_T) (*((unsigned long *) wlan0_dev->priv));
+
+			if (sta_existed(wlan0_dev, skb->mac.ethernet->h_dest, 0)) {
+				if (!process_br_learning(skb))
+					goto err;
+				memcpy(lan_cached_MAC, skb->mac.ethernet->h_source, ETH_ALEN);
+				skb->dev = wlan0_dev;
+				skb_push(skb, ETH_HLEN);
+				dev_queue_xmit(skb);
+				return 1;
+			}
+		}
+	 } else if (strstr(dev->name, "wds") != NULL) {
+
+        if (!process_br_learning(skb))
+		   goto err;
+        
+		if (wlan0_dev != NULL) {
+
+			sta_existed = (FUN_CALL_T) (*((unsigned long *) wlan0_dev->priv));
+            
+            /* if a wireless sta orginally associated with this AP
+             * now it switches to associate anothor AP with which the WDS is built
+             * we check the source HW mac to speed the age process to this moving station
+             */
+			sta_existed(wlan0_dev, skb->mac.ethernet->h_source, 1);
+		}
+	 }
+	
+	return 0;
+	
+err:
+	kfree_skb(skb);
+	return 1;
+}
+
+
 static int process_backlog(struct net_device *backlog_dev, int *budget)
 {
 	int work = 0;
@@ -1566,8 +2074,16 @@
 
 		dev = skb->dev;
 
+		if (process_fast_rt(skb))
+			goto fast_rt_done;
+
+		if (process_fast_br(skb))
+			goto fast_br_done;
+			
 		netif_receive_skb(skb);
 
+fast_rt_done:
+fast_br_done:
 		dev_put(dev);
 
 		work++;
diff -bBurN linux-2.4.32-uc0-wl530g/net/ipv4/ip_input.c linux-2.4.32-uc0-wl530g.fastrt/net/ipv4/ip_input.c
--- linux-2.4.32-uc0-wl530g/net/ipv4/ip_input.c	2005-07-20 04:27:10.000000000 +0300
+++ linux-2.4.32-uc0-wl530g.fastrt/net/ipv4/ip_input.c	2006-09-10 16:33:33.000000000 +0300
@@ -300,7 +300,8 @@
 		       ip_local_deliver_finish);
 }
 
-static inline int ip_rcv_finish(struct sk_buff *skb)
+//static, marked by Chen-I
+inline int ip_rcv_finish(struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
 	struct iphdr *iph = skb->nh.iph;
diff -bBurN linux-2.4.32-uc0-wl530g/net/ipv4/netfilter/ip_conntrack_standalone.c linux-2.4.32-uc0-wl530g.fastrt/net/ipv4/netfilter/ip_conntrack_standalone.c
--- linux-2.4.32-uc0-wl530g/net/ipv4/netfilter/ip_conntrack_standalone.c	2005-11-08 02:01:58.000000000 +0200
+++ linux-2.4.32-uc0-wl530g.fastrt/net/ipv4/netfilter/ip_conntrack_standalone.c	2006-09-10 16:33:33.000000000 +0300
@@ -333,7 +333,8 @@
 	return ip_conntrack_confirm(*pskb);
 }
 
-static unsigned int ip_refrag(unsigned int hooknum,
+//static, marked by Chen-I
+unsigned int ip_refrag(unsigned int hooknum,
 			      struct sk_buff **pskb,
 			      const struct net_device *in,
 			      const struct net_device *out,
diff -bBurN linux-2.4.32-uc0-wl530g/net/ipv4/netfilter/ip_nat_standalone.c linux-2.4.32-uc0-wl530g.fastrt/net/ipv4/netfilter/ip_nat_standalone.c
--- linux-2.4.32-uc0-wl530g/net/ipv4/netfilter/ip_nat_standalone.c	2006-01-10 06:40:22.000000000 +0200
+++ linux-2.4.32-uc0-wl530g.fastrt/net/ipv4/netfilter/ip_nat_standalone.c	2006-09-10 16:33:33.000000000 +0300
@@ -58,7 +58,8 @@
 	return master->nat.info.helper->expect(pskb, hooknum, ct, info);
 }
 
-static unsigned int
+//static, marked by Chen-I
+unsigned int
 ip_nat_fn(unsigned int hooknum,
 	  struct sk_buff **pskb,
 	  const struct net_device *in,
@@ -184,7 +185,8 @@
 	return ret;
 }
 
-static unsigned int
+//static, marked by Chen-I
+unsigned int
 ip_nat_out(unsigned int hooknum,
 	   struct sk_buff **pskb,
 	   const struct net_device *in,
diff -bBurN linux-2.4.32-uc0-wl530g/net/ipv4/netfilter/iptable_filter.c linux-2.4.32-uc0-wl530g.fastrt/net/ipv4/netfilter/iptable_filter.c
--- linux-2.4.32-uc0-wl530g/net/ipv4/netfilter/iptable_filter.c	2002-09-12 03:32:55.000000000 +0300
+++ linux-2.4.32-uc0-wl530g.fastrt/net/ipv4/netfilter/iptable_filter.c	2006-09-10 16:33:33.000000000 +0300
@@ -86,7 +86,8 @@
     FILTER_VALID_HOOKS, RW_LOCK_UNLOCKED, NULL, THIS_MODULE };
 
 /* The work comes in here from netfilter.c. */
-static unsigned int
+//static, marked by Chen-I
+unsigned int
 ipt_hook(unsigned int hook,
 	 struct sk_buff **pskb,
 	 const struct net_device *in,
diff -bBurN linux-2.4.32-uc0-wl530g/net/netsyms.c linux-2.4.32-uc0-wl530g.fastrt/net/netsyms.c
--- linux-2.4.32-uc0-wl530g/net/netsyms.c	2005-10-19 09:33:51.000000000 +0300
+++ linux-2.4.32-uc0-wl530g.fastrt/net/netsyms.c	2006-09-10 16:33:33.000000000 +0300
@@ -637,4 +637,7 @@
 EXPORT_SYMBOL(wireless_spy_update);
 #endif /* CONFIG_NET_RADIO || CONFIG_NET_PCMCIA_RADIO */
 
+extern void set_bypass_fast_rt();
+EXPORT_SYMBOL(set_bypass_fast_rt); //Added by Chen-I 
+
 #endif  /* CONFIG_NET */
